{"version":3,"sources":["webpack:///webpack/bootstrap 3fae93d1a5198847dab7","webpack:///./src/index.js","webpack:///external \"mz\"","webpack:///external \"when\"","webpack:///./src/amo-client.js","webpack:///external \"deepcopy\"","webpack:///external \"fs\"","webpack:///external \"url\"","webpack:///external \"path\"","webpack:///external \"jsonwebtoken\"","webpack:///external \"request\"","webpack:///./~/when/node.js","webpack:///./~/when/when.js","webpack:///./~/when/lib/decorators/timed.js","webpack:///./~/when/lib/env.js","webpack:///(webpack)/buildin/amd-define.js","webpack:///./~/when/lib/TimeoutError.js","webpack:///./~/when/lib/decorators/array.js","webpack:///./~/when/lib/state.js","webpack:///./~/when/lib/apply.js","webpack:///./~/when/lib/decorators/flow.js","webpack:///./~/when/lib/decorators/fold.js","webpack:///./~/when/lib/decorators/inspect.js","webpack:///./~/when/lib/decorators/iterate.js","webpack:///./~/when/lib/decorators/progress.js","webpack:///./~/when/lib/decorators/with.js","webpack:///./~/when/lib/decorators/unhandledRejection.js","webpack:///./~/when/lib/format.js","webpack:///./~/when/lib/Promise.js","webpack:///./~/when/lib/makePromise.js","webpack:///./~/when/lib/Scheduler.js","webpack:///./~/when/lib/liftAll.js"],"names":["signAddon","signAddonAndExit","xpiPath","id","version","apiKey","apiSecret","apiUrlPrefix","apiJwtExpiresIn","verbose","timeout","downloadDir","apiProxy","apiRequestConfig","AMOClient","promise","resolve","reportEmpty","name","Error","then","stat","catch","statError","stats","isFile","client","debugLogging","signedStatusCheckTimeout","proxyServer","requestConfig","sign","guid","options","systemProcess","process","throwError","logger","console","result","log","success","exit","err","error","stack","formatResponse","getUrlBasename","defaultSetInterval","setInterval","defaultClearInterval","clearInterval","Client","signedStatusCheckInterval","cwd","fs","request","validateProgress","_validateProgress","PseudoProgress","preamble","_fs","_request","formData","upload","createReadStream","addonUrl","method","encodeURIComponent","debug","doRequest","bind","url","throwOnBadResponse","responseResult","httpResponse","response","acceptableStatuses","receivedError","indexOf","statusCode","absoluteURL","JSON","stringify","headers","waitForSignedAddon","statusUrl","opt","lastStatusResponse","clearTimeout","setAbortTimeout","setTimeout","setStatusCheckTimeout","abortAfter","reject","animate","statusCheckTimeout","nextStatusCheck","checkSignedStatus","get","data","apiReportsAutoSigning","automated_signing","canBeAutoSigned","failedValidation","valid","signedAndReady","active","reviewed","files","length","requiresManualReview","processed","finish","validation_url","downloadSignedFiles","signedFiles","createWriteStream","stdout","allDownloads","dataExpected","dataReceived","showProgress","progress","amount","toFixed","padding","Array","join","e","write","download","fileUrl","fileName","out","configureRequest","followRedirect","on","contentLength","parseInt","chunk","pipe","foundUnsignedFiles","forEach","file","signed","push","download_url","all","downloadedFiles","replace","arguments","match","requestConf","jwt","proxy","authToken","iss","algorithm","expiresIn","Authorization","Accept","toLowerCase","toUpperCase","requestMethod","call","body","parse","redact","obj","hdr","Object","keys","key","args","prototype","map","val","bucket","interval","motionCounter","addendum","shellWidth","isTTY","columns","emptyBucketPointers","bucketSize","i","conf","speed","bucketIsFull","moveBucket","randomlyFillBucket","fillBucket","randomIndex","Math","floor","random","pointer","showBucket","isFull","newPointers","maxLength","prettyResponse","substring","toString","absUrl","urlPath","basename","path","parts","split"],"mappings":"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CAA,0C;;;;;;ACAA,qC;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB,aAAY,MAAM;AAClB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAkD;AAClD,0CAAyC;AACzC,iCAAgC;AAChC;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,iCAAgC,YAAY;AAC5C,iEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB,aAAY,KAAK;AACjB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB,aAAY,KAAK;AACjB,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,gBAAgB;AAC5B,aAAY,UAAU;AACtB;AACA;AACA,aAAY,mBAAmB;AAC/B;AACA,eAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,aAAY,SAAS;AACrB,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,SAAS;AACrB,eAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED,EAAC,yBAAiH;;;;;;;;;;ACtRlH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA,6BAA4B;AAC5B,qCAAoC;AACpC,oCAAmC;;AAEnC,0BAAyB;AACzB,6BAA4B;AAC5B,6BAA4B;;AAE5B,qCAAoC;AACpC,oCAAmC;;AAEnC,0BAAyB;;AAEzB,yBAAwB;AACxB,4BAA2B;;AAE3B,uCAAsC;AACtC,wCAAuC;AACvC,wCAAuC;;AAEvC,yBAAwB;AACxB,4BAA2B;AAC3B,0CAAyC;AACzC,+CAA8C;;AAE9C,qCAAoC;;AAEpC,6BAA4B;AAC5B,2BAA0B,6BAA6B,yBAAyB;;AAEhF;;AAEA;;AAEA;AACA;AACA;AACA,aAAY,EAAE;AACd,aAAY,UAAU;AACtB;AACA;AACA,aAAY,UAAU;AACtB;AACA,aAAY,UAAU;AACtB;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,SAAS;AACrB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,SAAS;AACrB,eAAc,SAAS;AACvB;AACA;AACA;AACA,oDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,SAAS;AACrB,eAAc;AACd;AACA;AACA;AACA,qDAAoD,KAAK;AACzD;AACA;AACA;AACA;;AAEA;AACA,gBAAe,kBAAkB;AACjC;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB,uBAAuB;AAC9C,uBAAsB,sBAAsB;AAC5C,uBAAsB,sBAAsB;;AAE5C;AACA;AACA;AACA;AACA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,EAAE;AACd,eAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,cAAc;AAC1B,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,cAAc;AAC1B,eAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,cAAc;AAC1B,aAAY,8BAA8B;AAC1C;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,aAAY,cAAc;AAC1B,aAAY,oCAAoC;AAChD;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA,EAAC;AACD,EAAC,yBAAiH;;;;;;;ACnOlH;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAqB;AACrB,MAAK;AACL;AACA;AACA,qBAAoB;AACpB,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;AACD,EAAC,wBAA+G;;;;;;;mCC7EhH;AACA;AACA;;AAEA;AACA,oBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAiC,0BAA0B;AAC3D,gCAA+B,wBAAwB;AACvD,2BAA0B,iCAAiC;;AAE3D;AACA,iBAAgB;AAChB,wBAAuB,4BAA4B;;AAEnD,GAAE,gDAAgD;AAClD;;AAEA,GAAE,gCAAgC;AAClC;AACA;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,EAAC,wBAA+G;;;;;;;ACxEhH,8BAA6B,mDAAmD;;;;;;;ACAhF;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAC;AACD,EAAC,wBAAwG,G;;;;;;AC1BzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAoB;AACpB;;AAEA;AACA;AACA,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,OAAO;AACpB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY;;AAEZ;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,8BAA8B;AAC3C,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,oCAAoC;AACjD;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,cAAc;AAC3B;AACA,cAAa,6CAA6C;AAC1D,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,cAAc;AAC3B;AACA,cAAa,6CAA6C;AAC1D,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;AACD,EAAC,wBAA+G;;;;;;;AChShH;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAU;AACV;;AAEA;AACA,WAAU;AACV;;AAEA;AACA,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;AClCzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,mEAAmE;;AAEtF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;;;ACpDzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,UAAU;AACvB,cAAa,UAAU;AACvB,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,UAAU;AACvB,cAAa,SAAS;AACtB,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA,qCAAoC,cAAc,EAAE;AACpD,eAAc,EAAE;AAChB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;AC/JzG;AACA;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;AC1BzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;AACD,EAAC,wBAA+G;;;;;;;ACnBhH;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;AACA,cAAa,SAAS;AACtB,cAAa,UAAU;AACvB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB;AACA,cAAa,SAAS;AACtB;AACA,cAAa,SAAS;AACtB,gBAAe,UAAU;AACzB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;AChEzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;ACvBzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;;ACpCzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,uBAAuB;AAC3C,qBAAoB,qBAAqB;;AAEzC;AACA,qBAAoB,sBAAsB;AAC1C,qBAAoB,qBAAqB;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAC;AACD,EAAC,wBAA+G;;;;;;;ACrFhH;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,EAAE;AACd,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,EAAE;AACd,aAAY,EAAE;AACd,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;ACvDzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF,EAAC;AACD,EAAC,yBAAiH;;;;;;;AChBlH;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc,EAAE;AAChB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,EAAE;AACf,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA,iCAAgC;AAChC;;AAEA;AACA,2BAA0B,kBAAkB;AAC5C;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,UAAU;AACvB,cAAa,UAAU;AACvB,cAAa,UAAU;AACvB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,UAAU;AACvB,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,MAAM;AACnB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,2CAA2C;AAChE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,mBAAmB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,EAAE;AACf,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,wBAAwB;AACrC,gBAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,EAAE;AACf,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,eAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB,cAAc;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,gBAAgB;AAC7B,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAAyB,cAAc;AACvC,0BAAyB,aAAa;AACtC,0BAAyB,aAAa;AACtC;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAc,YAAY,YAAY;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,cAAa,EAAE;AACf,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,QAAO;;AAEP;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,EAAC;AACD,EAAC,wBAAwG;;;;;;;AC95BzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ,oBAAoB;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA,cAAa,yBAAyB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,EAAC;AACD,EAAC,wBAAwG;;;;;;;AC/EzG;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;AACD,EAAC,wBAAwG","file":"sign-addon.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3fae93d1a5198847dab7\n **/","// Importing this like `import fs from \"mz/fs\"` was causing usage on\n// npm 2.x to throw missing dependency errors. *shrug*\nimport {fs} from \"mz\";\nimport when from \"when\";\n\nimport {Client as DefaultAMOClient} from \"./amo-client\";\n\n\nexport default function signAddon(\n  {\n    // Absolute path to add-on XPI file.\n    xpiPath,\n    // The add-on ID as recognized by AMO. Example: my-addon@jetpack\n    id,\n    // The add-on version number for AMO.\n    version,\n    // Your API key (JWT issuer) from AMO Devhub.\n    apiKey,\n    // Your API secret (JWT secret) from AMO Devhub.\n    apiSecret,\n    // Optional arguments:\n    apiUrlPrefix=\"https://addons.mozilla.org/api/v3\",\n    // Number of seconds until the JWT token for the API request expires.\n    // This must match the expiration time that the API server accepts.\n    apiJwtExpiresIn,\n    verbose=false,\n    // Number of milleseconds to wait before giving up on a\n    // response from Mozilla's web service.\n    timeout,\n    // Absolute directory to save downloaded files in.\n    downloadDir,\n    // Optional proxy to use for all API requests,\n    // such as \"http://yourproxy:6000\"\n    apiProxy,\n    // Optional object to pass into request() for additional configuration.\n    // Not all properties are guaranteed to be applied.\n    apiRequestConfig,\n    AMOClient=DefaultAMOClient,\n  }) {\n\n  return when.promise(\n    (resolve) => {\n\n      function reportEmpty(name) {\n        throw new Error(`required argument was empty: ${name}`);\n      }\n\n      if (!xpiPath) {\n        reportEmpty(\"xpiPath\");\n      }\n      if (!version) {\n        reportEmpty(\"version\");\n      }\n      if (!apiSecret) {\n        reportEmpty(\"apiSecret\");\n      }\n      if (!apiKey) {\n        reportEmpty(\"apiKey\");\n      }\n\n      resolve();\n    })\n    .then(() => fs.stat(xpiPath))\n    .catch((statError) => {\n      throw new Error(`error with ${xpiPath}: ${statError}`);\n    })\n    .then((stats) => {\n      if (!stats.isFile) {\n        throw new Error(`not a file: ${xpiPath}`);\n      }\n    })\n    .then(() => {\n\n      let client = new AMOClient({\n        apiKey,\n        apiSecret,\n        apiUrlPrefix,\n        apiJwtExpiresIn,\n        downloadDir,\n        debugLogging: verbose,\n        signedStatusCheckTimeout: timeout,\n        proxyServer: apiProxy,\n        requestConfig: apiRequestConfig,\n      });\n\n      return client.sign({\n        xpiPath: xpiPath,\n        guid: id,\n        version: version,\n      });\n\n    });\n}\n\n\nexport function signAddonAndExit(\n    options, {systemProcess=process, throwError=false, logger=console}) {\n  return signAddon(options)\n    .then((result) => {\n      logger.log(result.success ? \"SUCCESS\" : \"FAIL\");\n      systemProcess.exit(result.success ? 0 : 1);\n    })\n    .catch((err) => {\n      logger.error(\"FAIL\");\n      if (throwError) {\n        throw err;\n      }\n      logger.error(err.stack);\n      systemProcess.exit(1);\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","module.exports = require(\"mz\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"mz\"\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = require(\"when\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"when\"\n ** module id = 2\n ** module chunks = 0\n **/","import deepcopy from \"deepcopy\";\nimport {default as defaultFs} from \"fs\";\nimport url from \"url\";\nimport path from \"path\";\nimport defaultJwt from \"jsonwebtoken\";\nimport {default as defaultRequest} from \"request\";\nimport when from \"when\";\nimport nodefn from \"when/node\";\n\nconst defaultSetInterval = setInterval;\nconst defaultClearInterval = clearInterval;\n\n/**\n * Construct a new addons.mozilla.org API client.\n *\n * @param {Object} conf\n *   - `apiKey`: API key string from the Developer Hub.\n *   - `apiSecret`: API secret string from the Developer Hub.\n *   - `apiUrlPrefix`: API URL prefix, including any leading paths.\n *   - `apiJwtExpiresIn`: Number of seconds until the JWT token for the API\n *     request expires. This must match the expiration time that the API\n *     server accepts.\n *   - `signedStatusCheckInterval`: A period in millesconds between\n *     checks when waiting on add-on signing.\n *   - `signedStatusCheckTimeout`: A length in millesconds to give up\n *      if the add-on hasn't been signed.\n *   - `debugLogging`: When true, log more information\n *   - `downloadDir`: Absolute path to save downloaded files to.\n *     The working directory will be used by default.\n *   - `proxyServer`: Optional proxy server to use for all requests,\n *     such as \"http://yourproxy:6000\"\n *   - `requestConfig`: Optional configuration object to pass to\n *     request(). Not all parameters are guaranteed to be applied.\n */\nexport class Client {\n  constructor({apiKey,\n               apiSecret,\n               apiUrlPrefix,\n               // TODO: put this back to something sane after we\n               // address the file upload issue on AMO:\n               // https://github.com/mozilla/addons-server/issues/3688\n               apiJwtExpiresIn=60 * 5,  // 5 minutes\n               debugLogging=false,\n               signedStatusCheckInterval=1000,\n               signedStatusCheckTimeout=120000,  // 2 minutes.\n               logger=console,\n               downloadDir=process.cwd(),\n               fs=defaultFs,\n               request=defaultRequest,\n               proxyServer,\n               requestConfig,\n               validateProgress}) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.apiUrlPrefix = apiUrlPrefix;  // default set in CLI options.\n    this.apiJwtExpiresIn = apiJwtExpiresIn;\n    this.signedStatusCheckInterval = signedStatusCheckInterval;\n    this.signedStatusCheckTimeout = signedStatusCheckTimeout;\n    this.debugLogging = debugLogging;\n    this.logger = logger;\n    this.downloadDir = downloadDir;\n    this.proxyServer = proxyServer;\n    this.requestConfig = requestConfig || {};\n\n    // Set up external dependencies, allowing for overrides.\n    this._validateProgress = validateProgress || new PseudoProgress({\n      preamble: \"Validating add-on\",\n    });\n    this._fs = fs;\n    this._request = request;\n  }\n\n  /**\n   * Sign a new version of your add-on at addons.mozilla.org.\n   *\n   * @param {Object} conf\n   *   - `xpiPath` Path to xpi file.\n   *   - `guid` Optional add-on GUID, aka the ID in install.rdf.\n   *   - `version` add-on version string.\n   * @return {Promise} signingResult with keys:\n   *   - success: boolean\n   *   - downloadedFiles: Array of file objects\n   *   - id: string identifier for the signed add-on\n   */\n  sign({guid, version, xpiPath}) {\n\n    const formData = {\n      upload: this._fs.createReadStream(xpiPath),\n    };\n    let addonUrl = \"/addons/\";\n    let method = \"put\";\n    if (guid) {\n      // PUT to a specific URL for this add-on + version.\n      addonUrl += encodeURIComponent(guid) +\n        \"/versions/\" + encodeURIComponent(version) + \"/\";\n    } else {\n      // POST to a generic URL to create a new add-on.\n      this.debug(\"Signing add-on without an ID\");\n      method = \"post\";\n      formData.version = version;\n    }\n\n    const doRequest = this[method].bind(this);\n\n    return doRequest({\n      url: addonUrl, formData,\n    }, {\n      throwOnBadResponse: false,\n    }).then((responseResult) => {\n      const httpResponse = responseResult[0] || {};\n      const response = responseResult[1] || {};\n\n      const acceptableStatuses = [200, 201, 202];\n      const receivedError = !!response.error;\n      if (acceptableStatuses.indexOf(httpResponse.statusCode) === -1\n          || receivedError) {\n        if (response.error) {\n          this.logger.error(`Server response: ${response.error}`,\n                            `(status: ${httpResponse.statusCode})`);\n          return {success: false};\n        }\n\n        throw new Error(\n          \"Received bad response from the server while requesting \" +\n          this.absoluteURL(addonUrl) +\n          \"\\n\\n\" + \"status: \" + httpResponse.statusCode + \"\\n\" +\n          \"response: \" + formatResponse(response) + \"\\n\" + \"headers: \" +\n          JSON.stringify(httpResponse.headers || {}) + \"\\n\");\n      }\n\n      return this.waitForSignedAddon(response.url);\n    });\n  }\n\n  /**\n   * Poll a status URL, waiting for the queued add-on to be signed.\n   *\n   * @param {String} URL to GET for add-on status.\n   * @return {Promise}\n   */\n  waitForSignedAddon(statusUrl, opt) {\n    var lastStatusResponse;\n\n    opt = {\n      clearTimeout: clearTimeout,\n      setAbortTimeout: setTimeout,\n      setStatusCheckTimeout: setTimeout,\n      abortAfter: this.signedStatusCheckTimeout,\n      ...opt,\n    };\n\n    return when.promise((resolve, reject) => {\n      this._validateProgress.animate();\n      var statusCheckTimeout;\n      var nextStatusCheck;\n\n      const checkSignedStatus = () => {\n        return this.get({url: statusUrl}).then((result) => {\n          var data = result[1];\n          lastStatusResponse = data;\n\n          // TODO: remove this when the API has been fully deployed with this\n          // change: https://github.com/mozilla/olympia/pull/1041\n          var apiReportsAutoSigning = typeof data.automated_signing !==\n              \"undefined\";\n\n          var canBeAutoSigned = data.automated_signing;\n          var failedValidation = !data.valid;\n          // The add-on passed validation and all files have been created.\n          // There are many checks for this state because the data will be\n          // updated incrementally by the API server.\n          var signedAndReady = data.valid && data.active && data.reviewed &&\n                               data.files && data.files.length > 0;\n          // The add-on is valid but requires a manual review before it can\n          // be signed.\n          var requiresManualReview = data.valid && apiReportsAutoSigning &&\n                                     !canBeAutoSigned;\n\n          if (data.processed &&\n                (failedValidation || signedAndReady || requiresManualReview)) {\n\n            this._validateProgress.finish();\n            opt.clearTimeout(statusCheckTimeout);\n            this.logger.log(\"Validation results:\", data.validation_url);\n\n            if (requiresManualReview) {\n              this.logger.log(\n                \"Your add-on has been submitted for review. It passed \" +\n                \"validation but could not be automatically signed \" +\n                \"because this is a listed add-on.\");\n              return resolve({success: false});\n            } else if (signedAndReady) {\n              // TODO: show some validation warnings if there are any.\n              // We should show things like \"missing update URL in install.rdf\"\n              return resolve(\n                this.downloadSignedFiles(data.files)\n                .then((result) => {\n                  return {\n                    id: data.guid,\n                    ...result,\n                  };\n                }));\n            } else {\n              this.logger.log(\n                \"Your add-on failed validation and could not be signed\");\n              return resolve({success: false});\n            }\n\n          } else {\n            // The add-on has not been fully processed yet.\n            nextStatusCheck = opt.setStatusCheckTimeout(\n                checkSignedStatus, this.signedStatusCheckInterval);\n          }\n        });\n      };\n\n      checkSignedStatus().catch(reject);\n\n      statusCheckTimeout = opt.setAbortTimeout(() => {\n        this._validateProgress.finish();\n        opt.clearTimeout(nextStatusCheck);\n        reject(new Error(\n            \"Validation took too long to complete; last status: \" +\n            formatResponse(lastStatusResponse || \"[null]\")));\n\n      }, opt.abortAfter);\n\n    });\n  }\n\n  /**\n   * Download the signed files.\n   *\n   * @param {Array} Array of file objects returned from the API.\n   *                Each object needs to have these parameters:\n   *                  - `download_url` - the URL to the file\n   * @return {Promise}\n   */\n  downloadSignedFiles(signedFiles,\n                      {createWriteStream=defaultFs.createWriteStream,\n                       request,\n                       stdout=process.stdout} = {}) {\n    if (!request) {\n      request = this._request;\n    }\n    var allDownloads = [];\n    var dataExpected = null;\n    var dataReceived = 0;\n\n    function showProgress() {\n      var progress = \"...\";\n      if (dataExpected !== null) {\n        var amount = ((dataReceived / dataExpected) * 100).toFixed();\n        // Pad the percentage amount so that the line length is consistent.\n        // This should do something like '  0%', ' 25%', '100%'\n        var padding = \"\";\n        try {\n          padding = Array(4 - amount.length).join(\" \");\n        } catch (e) {\n          // Ignore Invalid array length and such.\n        }\n        progress = padding + amount + \"% \";\n      }\n      stdout.write(\"\\r\" +\n          \"Downloading signed files: \" + progress);\n    }\n\n    const download = (fileUrl) => {\n      return when.promise((resolve, reject) => {\n        // The API will give us a signed file named in a sane way.\n        var fileName = path.join(this.downloadDir, getUrlBasename(fileUrl));\n        var out = createWriteStream(fileName);\n\n        request(\n          this.configureRequest({\n            method: \"GET\",\n            url: fileUrl,\n            followRedirect: true,\n          }))\n          .on(\"error\", reject)\n          .on(\"response\", (response) => {\n            if (response.statusCode < 200 || response.statusCode >= 300) {\n              throw new Error(\n                `Got a ${response.statusCode} response ` +\n                `when downloading ${fileUrl}`);\n            }\n            const contentLength = response.headers[\"content-length\"];\n            if (contentLength) {\n              dataExpected += parseInt(contentLength);\n            }\n          })\n          .on(\"data\", function(chunk) {\n            dataReceived += chunk.length;\n            showProgress();\n          })\n          .pipe(out)\n          .on(\"error\", reject);\n\n        out.on(\"finish\", function() {\n          stdout.write(\"\\n\");  // end the progress output\n          resolve(fileName);\n        });\n      });\n    };\n\n    return when.promise((resolve, reject) => {\n      var foundUnsignedFiles = false;\n      signedFiles.forEach((file) => {\n        if (file.signed) {\n          allDownloads.push(download(file.download_url));\n        } else {\n          this.debug(\"This file was not signed:\", file);\n          foundUnsignedFiles = true;\n        }\n      });\n\n      if (allDownloads.length) {\n        if (foundUnsignedFiles) {\n          this.logger.log(\n            \"Some files were not signed. Re-run with --verbose for details.\");\n        }\n        showProgress();\n        resolve(when.all(allDownloads));\n      } else {\n        reject(new Error(\n          \"The XPI was processed but no signed files were found. Check your \" +\n          \"manifest and make sure it targets Firefox as an application.\"));\n      }\n\n    }).then((downloadedFiles) => {\n      this.logger.log(\"Downloaded:\");\n      downloadedFiles.forEach((fileName) => {\n        this.logger.log(\"    \" + fileName.replace(process.cwd(), \".\"));\n      });\n      return {\n        success: true,\n        downloadedFiles: downloadedFiles,\n      };\n    });\n  }\n\n  /**\n   * Make a GET request.\n   *\n   * @param {Object} conf, as accepted by the `request` module.\n   * @param {Object} options, as accepted by `this.request()`.\n   * @return {Promise}\n   */\n  get() {\n    return this.request(\"get\", ...arguments);\n  }\n\n  /**\n   * Make a POST request.\n   *\n   * @param {Object} conf, as accepted by the `request` module.\n   * @param {Object} options, as accepted by `this.request()`.\n   * @return {Promise}\n   */\n  post() {\n    return this.request(\"post\", ...arguments);\n  }\n\n  /**\n   * Make a PUT request.\n   *\n   * @param {Object} conf, as accepted by the `request` module.\n   * @param {Object} options, as accepted by `this.request()`.\n   * @return {Promise}\n   */\n  put() {\n    return this.request(\"put\", ...arguments);\n  }\n\n  /**\n   * Make a PATCH request.\n   *\n   * @param {Object} conf, as accepted by the `request` module.\n   * @param {Object} options, as accepted by `this.request()`.\n   * @return {Promise}\n   */\n  patch() {\n    return this.request(\"patch\", ...arguments);\n  }\n\n  /**\n   * Make a DELETE request.\n   *\n   * @param {Object} conf, as accepted by the `request` module.\n   * @param {Object} options, as accepted by `this.request()`.\n   * @return {Promise}\n   */\n  delete() {\n    return this.request(\"delete\", ...arguments);\n  }\n\n  /**\n   * Returns a URL that is guaranteed to be absolute.\n   *\n   * @param {String} a relative or already absolute URL\n   * @return {String} an absolute URL, prefixed by the API prefix if necessary.\n   */\n  absoluteURL(url) {\n    if (!url.match(/^http/i)) {\n      url = this.apiUrlPrefix + url;\n    }\n    return url;\n  }\n\n  /**\n   * Configures a request with defaults such as authentication headers.\n   *\n   * @param {Object} requestConf as accepted by the `request` module.\n   * @return {Object} new requestConf object suitable\n   *                  for `request(conf)`, `request.get(conf)`, etc.\n   */\n  configureRequest(requestConf, {jwt=defaultJwt}={}) {\n    requestConf = {...this.requestConfig, ...requestConf};\n    if (!requestConf.url) {\n      throw new Error(\"request URL was not specified\");\n    }\n    requestConf.url = this.absoluteURL(requestConf.url);\n    if (this.proxyServer) {\n      requestConf.proxy = this.proxyServer;\n    }\n\n    var authToken = jwt.sign({iss: this.apiKey}, this.apiSecret, {\n      algorithm: \"HS256\",\n      expiresIn: this.apiJwtExpiresIn,\n    });\n\n    // Make sure the request won't time out before the JWT expires.\n    // This may be useful for slow file uploads.\n    requestConf.timeout = (this.apiJwtExpiresIn * 1000) + 500;\n\n    requestConf.headers = {\n      Authorization: \"JWT \" + authToken,\n      Accept: \"application/json\",\n      ...requestConf.headers,\n    };\n\n    return requestConf;\n  }\n\n  /**\n   * Make any HTTP request to the addons.mozilla.org API.\n   *\n   * This includes the necessary authorization header.\n   *\n   * @param {String} method - HTTP method name.\n   * @param {Object} requestConf as accepted by the `request` module.\n   * @param {Object} options.\n   *  - `throwOnBadResponse` - if true, an error will be thrown when not\n   *                           response status is not 2xx\n   *\n   * The returned promise will be resolved with an array of arguments\n   * that match the arguments sent to the callback as specified in the\n   * `request` module.\n   *\n   * @return {Promise}\n   */\n  request(method, requestConf, {throwOnBadResponse=true} = {}) {\n    method = method.toLowerCase();\n    return when.promise((resolve) => {\n      requestConf = this.configureRequest(requestConf);\n      this.debug(`[API] ${method.toUpperCase()} request:\\n`, requestConf);\n\n      // Get the caller, like request.get(), request.put() ...\n      var requestMethod = this._request[method].bind(this._request);\n      // Wrap the request callback in a promise. Here is an example without\n      // promises:\n      //\n      // request.put(requestConf, function(err, httpResponse, body) {\n      //   // promise gets resolved here\n      // })\n      //\n      resolve(nodefn.call(requestMethod, requestConf));\n\n    }).then((responseResult) => {\n      var httpResponse = responseResult[0];\n      var body = responseResult[1];\n\n      if (throwOnBadResponse) {\n        if (httpResponse.statusCode > 299 || httpResponse.statusCode < 200) {\n          throw new Error(\n            \"Received bad response from \" +\n            this.absoluteURL(requestConf.url) + \"; \" +\n            \"status: \" + httpResponse.statusCode + \"; \" +\n            \"response: \" + formatResponse(body));\n        }\n      }\n\n      if (\n        httpResponse.headers &&\n          httpResponse.headers[\"content-type\"] === \"application/json\" &&\n          typeof body === \"string\"\n      ) {\n        try {\n          body = JSON.parse(body);\n        } catch (e) {\n          this.logger.log(\"Failed to parse JSON response from server:\", e);\n        }\n      }\n      this.debug(`[API] ${method.toUpperCase()} response:\\n`,\n                 `Status: ${httpResponse.statusCode}\\n`,\n                 {headers: httpResponse.headers, response: body});\n\n      return [httpResponse, body];\n    });\n  }\n\n  /**\n   * Output some debugging info if this instance is configured for it.\n   */\n  debug() {\n    if (!this.debugLogging) {\n      return;\n    }\n\n    function redact(obj) {\n      if (typeof obj !== \"object\" || !obj) {\n        return obj;\n      }\n      if (obj.headers) {\n        [\"Authorization\", \"cookie\", \"set-cookie\"].forEach(function(hdr) {\n          if (obj.headers[hdr]) {\n            obj.headers[hdr] = \"<REDACTED>\";\n          }\n        });\n      }\n      Object.keys(obj).forEach(function(key) {\n        obj[key] = redact(obj[key]);\n      });\n      return obj;\n    }\n\n    var args = Array.prototype.map.call(arguments, function(val) {\n      if (typeof val === \"object\") {\n        val = deepcopy(val);\n        val = redact(val);\n      }\n      return val;\n    });\n    this.logger.log(\"[sign-addon]\", ...args);\n  }\n}\n\n\n/**\n * A pseudo progress indicator.\n *\n * This is just a silly shell animation that was meant to simulate how lots of\n * tests would be run on an add-on file. It sort of looks like a torrent file\n * randomly getting filled in.\n */\nexport class PseudoProgress {\n  constructor({preamble=\"\",\n               setInterval=defaultSetInterval,\n               clearInterval=defaultClearInterval,\n               stdout=process.stdout} = {}) {\n\n    this.bucket = [];\n    this.interval = null;\n    this.motionCounter = 1;\n\n    this.preamble = preamble;\n    this.preamble += \" [\";\n    this.addendum = \"]\";\n    this.setInterval = setInterval;\n    this.clearInterval = clearInterval;\n    this.stdout = stdout;\n\n    var shellWidth = 80;\n    if (this.stdout.isTTY) {\n      shellWidth = this.stdout.columns;\n    }\n\n    this.emptyBucketPointers = [];\n    var bucketSize = shellWidth - this.preamble.length - this.addendum.length;\n    for (var i = 0; i < bucketSize; i++) {\n      this.bucket.push(\" \");\n      this.emptyBucketPointers.push(i);\n    }\n  }\n\n  animate(conf) {\n    conf = {\n      speed: 100,\n      ...conf,\n    };\n    var bucketIsFull = false;\n    this.interval = this.setInterval(() => {\n      if (bucketIsFull) {\n        this.moveBucket();\n      } else {\n        bucketIsFull = this.randomlyFillBucket();\n      }\n    }, conf.speed);\n  }\n\n  finish() {\n    this.clearInterval(this.interval);\n    this.fillBucket();\n    // The bucket has already filled to the terminal width at this point\n    // but for copy/paste purposes, add a new line:\n    this.stdout.write(\"\\n\");\n  }\n\n  randomlyFillBucket() {\n    // randomly fill a bucket (the width of the shell) with dots.\n    var randomIndex = Math.floor(Math.random() *\n                                 this.emptyBucketPointers.length);\n    var pointer = this.emptyBucketPointers[randomIndex];\n    this.bucket[pointer] = \".\";\n\n    this.showBucket();\n\n    var isFull = true;\n    var newPointers = [];\n    this.emptyBucketPointers.forEach((pointer) => {\n      if (this.bucket[pointer] === \" \") {\n        isFull = false;\n        newPointers.push(pointer);\n      }\n    });\n    this.emptyBucketPointers = newPointers;\n\n    return isFull;\n  }\n\n  fillBucket() {\n    // fill the whole bucket with dots to indicate completion.\n    this.bucket = this.bucket.map(function() {\n      return \".\";\n    });\n    this.showBucket();\n  }\n\n  moveBucket() {\n    // animate dots moving in a forward motion.\n    for (var i = 0; i < this.bucket.length; i++) {\n      this.bucket[i] = ((i - this.motionCounter) % 3) ? \" \" : \".\";\n    }\n    this.showBucket();\n\n    this.motionCounter ++;\n  }\n\n  showBucket() {\n    this.stdout.write(\"\\r\" + this.preamble + this.bucket.join(\"\") +\n                      this.addendum);\n  }\n}\n\n/**\n * Returns a nicely formatted HTTP response.\n *\n * This makes the response suitable for logging.\n * */\nexport function formatResponse(response, options) {\n  options = {\n    maxLength: 500,\n    ...options,\n  };\n  var prettyResponse = response;\n  if (typeof prettyResponse === \"object\") {\n    try {\n      prettyResponse = JSON.stringify(prettyResponse);\n    } catch (e) {\n      //\n    }\n  }\n  if (typeof prettyResponse === \"string\") {\n    if (prettyResponse.length > options.maxLength) {\n      prettyResponse = prettyResponse.substring(0, options.maxLength) + \"...\";\n    }\n  }\n  return prettyResponse.toString();\n}\n\n/**\n * Returns the basename of a URL, suitable for saving to disk.\n * */\nexport function getUrlBasename(absUrl) {\n  var urlPath = path.basename(url.parse(absUrl).path);\n  var parts = urlPath.split(\"?\");\n  return parts[0];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/amo-client.js\n **/","module.exports = require(\"deepcopy\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"deepcopy\"\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = require(\"fs\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"fs\"\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = require(\"url\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"url\"\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = require(\"path\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"path\"\n ** module id = 7\n ** module chunks = 0\n **/","module.exports = require(\"jsonwebtoken\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"jsonwebtoken\"\n ** module id = 8\n ** module chunks = 0\n **/","module.exports = require(\"request\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"request\"\n ** module id = 9\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2013 original author or authors */\n\n/**\n * Collection of helpers for interfacing with node-style asynchronous functions\n * using promises.\n *\n * @author Brian Cavalier\n * @contributor Renato Zannon\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar _liftAll = require('./lib/liftAll');\n\tvar setTimer = require('./lib/env').setTimer;\n\tvar slice = Array.prototype.slice;\n\n\tvar _apply = require('./lib/apply')(when.Promise, dispatch);\n\n\treturn {\n\t\tlift: lift,\n\t\tliftAll: liftAll,\n\t\tapply: apply,\n\t\tcall: call,\n\t\tcreateCallback: createCallback,\n\t\tbindCallback: bindCallback,\n\t\tliftCallback: liftCallback\n\t};\n\n\t/**\n\t * Takes a node-style async function and calls it immediately (with an optional\n\t * array of arguments or promises for arguments). It returns a promise whose\n\t * resolution depends on whether the async functions calls its callback with the\n\t * conventional error argument or not.\n\t *\n\t * With this it becomes possible to leverage existing APIs while still reaping\n\t * the benefits of promises.\n\t *\n\t * @example\n\t *    function onlySmallNumbers(n, callback) {\n\t *\t\tif(n < 10) {\n\t *\t\t\tcallback(null, n + 10);\n\t *\t\t} else {\n\t *\t\t\tcallback(new Error(\"Calculation failed\"));\n\t *\t\t}\n\t *\t}\n\t *\n\t *    var nodefn = require(\"when/node/function\");\n\t *\n\t *    // Logs '15'\n\t *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);\n\t *\n\t *    // Logs 'Calculation failed'\n\t *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);\n\t *\n\t * @param {function} f node-style function that will be called\n\t * @param {Array} [args] array of arguments to func\n\t * @returns {Promise} promise for the value func passes to its callback\n\t */\n\tfunction apply(f, args) {\n\t\treturn _apply(f, this, args || []);\n\t}\n\n\tfunction dispatch(f, thisArg, args, h) {\n\t\tvar cb = createCallback(h);\n\t\ttry {\n\t\t\tswitch(args.length) {\n\t\t\t\tcase 2: f.call(thisArg, args[0], args[1], cb); break;\n\t\t\t\tcase 1: f.call(thisArg, args[0], cb); break;\n\t\t\t\tcase 0: f.call(thisArg, cb); break;\n\t\t\t\tdefault:\n\t\t\t\t\targs.push(cb);\n\t\t\t\t\tf.apply(thisArg, args);\n\t\t\t}\n\t\t} catch(e) {\n\t\t\th.reject(e);\n\t\t}\n\t}\n\n\t/**\n\t * Has the same behavior that {@link apply} has, with the difference that the\n\t * arguments to the function are provided individually, while {@link apply} accepts\n\t * a single array.\n\t *\n\t * @example\n\t *    function sumSmallNumbers(x, y, callback) {\n\t *\t\tvar result = x + y;\n\t *\t\tif(result < 10) {\n\t *\t\t\tcallback(null, result);\n\t *\t\t} else {\n\t *\t\t\tcallback(new Error(\"Calculation failed\"));\n\t *\t\t}\n\t *\t}\n\t *\n\t *    // Logs '5'\n\t *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);\n\t *\n\t *    // Logs 'Calculation failed'\n\t *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);\n\t *\n\t * @param {function} f node-style function that will be called\n\t * @param {...*} [args] arguments that will be forwarded to the function\n\t * @returns {Promise} promise for the value func passes to its callback\n\t */\n\tfunction call(f /*, args... */) {\n\t\treturn _apply(f, this, slice.call(arguments, 1));\n\t}\n\n\t/**\n\t * Takes a node-style function and returns new function that wraps the\n\t * original and, instead of taking a callback, returns a promise. Also, it\n\t * knows how to handle promises given as arguments, waiting for their\n\t * resolution before executing.\n\t *\n\t * Upon execution, the orginal function is executed as well. If it passes\n\t * a truthy value as the first argument to the callback, it will be\n\t * interpreted as an error condition, and the promise will be rejected\n\t * with it. Otherwise, the call is considered a resolution, and the promise\n\t * is resolved with the callback's second argument.\n\t *\n\t * @example\n\t *    var fs = require(\"fs\"), nodefn = require(\"when/node/function\");\n\t *\n\t *    var promiseRead = nodefn.lift(fs.readFile);\n\t *\n\t *    // The promise is resolved with the contents of the file if everything\n\t *    // goes ok\n\t *    promiseRead('exists.txt').then(console.log, console.error);\n\t *\n\t *    // And will be rejected if something doesn't work out\n\t *    // (e.g. the files does not exist)\n\t *    promiseRead('doesnt_exist.txt').then(console.log, console.error);\n\t *\n\t *\n\t * @param {Function} f node-style function to be lifted\n\t * @param {...*} [args] arguments to be prepended for the new function @deprecated\n\t * @returns {Function} a promise-returning function\n\t */\n\tfunction lift(f /*, args... */) {\n\t\tvar args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];\n\t\treturn function() {\n\t\t\t// TODO: Simplify once partialing has been removed\n\t\t\tvar l = args1.length;\n\t\t\tvar al = arguments.length;\n\t\t\tvar args = new Array(al + l);\n\t\t\tvar i;\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\targs[i] = args1[i];\n\t\t\t}\n\t\t\tfor(i=0; i<al; ++i) {\n\t\t\t\targs[i+l] = arguments[i];\n\t\t\t}\n\t\t\treturn _apply(f, this, args);\n\t\t};\n\t}\n\n\t/**\n\t * Lift all the functions/methods on src\n\t * @param {object|function} src source whose functions will be lifted\n\t * @param {function?} combine optional function for customizing the lifting\n\t *  process. It is passed dst, the lifted function, and the property name of\n\t *  the original function on src.\n\t * @param {(object|function)?} dst option destination host onto which to place lifted\n\t *  functions. If not provided, liftAll returns a new object.\n\t * @returns {*} If dst is provided, returns dst with lifted functions as\n\t *  properties.  If dst not provided, returns a new object with lifted functions.\n\t */\n\tfunction liftAll(src, combine, dst) {\n\t\treturn _liftAll(lift, combine, dst, src);\n\t}\n\n\t/**\n\t * Takes an object that responds to the resolver interface, and returns\n\t * a function that will resolve or reject it depending on how it is called.\n\t *\n\t * @example\n\t *\tfunction callbackTakingFunction(callback) {\n\t *\t\tif(somethingWrongHappened) {\n\t *\t\t\tcallback(error);\n\t *\t\t} else {\n\t *\t\t\tcallback(null, interestingValue);\n\t *\t\t}\n\t *\t}\n\t *\n\t *\tvar when = require('when'), nodefn = require('when/node/function');\n\t *\n\t *\tvar deferred = when.defer();\n\t *\tcallbackTakingFunction(nodefn.createCallback(deferred.resolver));\n\t *\n\t *\tdeferred.promise.then(function(interestingValue) {\n\t *\t\t// Use interestingValue\n\t *\t});\n\t *\n\t * @param {Resolver} resolver that will be 'attached' to the callback\n\t * @returns {Function} a node-style callback function\n\t */\n\tfunction createCallback(resolver) {\n\t\treturn function(err, value) {\n\t\t\tif(err) {\n\t\t\t\tresolver.reject(err);\n\t\t\t} else if(arguments.length > 2) {\n\t\t\t\tresolver.resolve(slice.call(arguments, 1));\n\t\t\t} else {\n\t\t\t\tresolver.resolve(value);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Attaches a node-style callback to a promise, ensuring the callback is\n\t * called for either fulfillment or rejection. Returns a promise with the same\n\t * state as the passed-in promise.\n\t *\n\t * @example\n\t *\tvar deferred = when.defer();\n\t *\n\t *\tfunction callback(err, value) {\n\t *\t\t// Handle err or use value\n\t *\t}\n\t *\n\t *\tbindCallback(deferred.promise, callback);\n\t *\n\t *\tdeferred.resolve('interesting value');\n\t *\n\t * @param {Promise} promise The promise to be attached to.\n\t * @param {Function} callback The node-style callback to attach.\n\t * @returns {Promise} A promise with the same state as the passed-in promise.\n\t */\n\tfunction bindCallback(promise, callback) {\n\t\tpromise = when(promise);\n\n\t\tif (callback) {\n\t\t\tpromise.then(success, wrapped);\n\t\t}\n\n\t\treturn promise;\n\n\t\tfunction success(value) {\n\t\t\twrapped(null, value);\n\t\t}\n\n\t\tfunction wrapped(err, value) {\n\t\t\tsetTimer(function () {\n\t\t\t\tcallback(err, value);\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\t/**\n\t * Takes a node-style callback and returns new function that accepts a\n\t * promise, calling the original callback when the promise is either\n\t * fulfilled or rejected with the appropriate arguments.\n\t *\n\t * @example\n\t *\tvar deferred = when.defer();\n\t *\n\t *\tfunction callback(err, value) {\n\t *\t\t// Handle err or use value\n\t *\t}\n\t *\n\t *\tvar wrapped = liftCallback(callback);\n\t *\n\t *\t// `wrapped` can now be passed around at will\n\t *\twrapped(deferred.promise);\n\t *\n\t *\tdeferred.resolve('interesting value');\n\t *\n\t * @param {Function} callback The node-style callback to wrap.\n\t * @returns {Function} The lifted, promise-accepting function.\n\t */\n\tfunction liftCallback(callback) {\n\t\treturn function(promise) {\n\t\t\treturn bindCallback(promise, callback);\n\t\t};\n\t}\n});\n\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/node.js\n ** module id = 10\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * Promises/A+ and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n */\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar timed = require('./lib/decorators/timed');\n\tvar array = require('./lib/decorators/array');\n\tvar flow = require('./lib/decorators/flow');\n\tvar fold = require('./lib/decorators/fold');\n\tvar inspect = require('./lib/decorators/inspect');\n\tvar generate = require('./lib/decorators/iterate');\n\tvar progress = require('./lib/decorators/progress');\n\tvar withThis = require('./lib/decorators/with');\n\tvar unhandledRejection = require('./lib/decorators/unhandledRejection');\n\tvar TimeoutError = require('./lib/TimeoutError');\n\n\tvar Promise = [array, flow, fold, generate, progress,\n\t\tinspect, withThis, timed, unhandledRejection]\n\t\t.reduce(function(Promise, feature) {\n\t\t\treturn feature(Promise);\n\t\t}, require('./lib/Promise'));\n\n\tvar apply = require('./lib/apply')(Promise);\n\n\t// Public API\n\n\twhen.promise     = promise;              // Create a pending promise\n\twhen.resolve     = Promise.resolve;      // Create a resolved promise\n\twhen.reject      = Promise.reject;       // Create a rejected promise\n\n\twhen.lift        = lift;                 // lift a function to return promises\n\twhen['try']      = attempt;              // call a function and return a promise\n\twhen.attempt     = attempt;              // alias for when.try\n\n\twhen.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\twhen.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\n\twhen.join        = join;                 // Join 2 or more promises\n\n\twhen.all         = all;                  // Resolve a list of promises\n\twhen.settle      = settle;               // Settle a list of promises\n\n\twhen.any         = lift(Promise.any);    // One-winner race\n\twhen.some        = lift(Promise.some);   // Multi-winner race\n\twhen.race        = lift(Promise.race);   // First-to-settle race\n\n\twhen.map         = map;                  // Array.map() for promises\n\twhen.filter      = filter;               // Array.filter() for promises\n\twhen.reduce      = lift(Promise.reduce);       // Array.reduce() for promises\n\twhen.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises\n\n\twhen.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable\n\n\twhen.Promise     = Promise;              // Promise constructor\n\twhen.defer       = defer;                // Create a {promise, resolve, reject} tuple\n\n\t// Error types\n\n\twhen.TimeoutError = TimeoutError;\n\n\t/**\n\t * Get a trusted promise for x, or by transforming x with onFulfilled\n\t *\n\t * @param {*} x\n\t * @param {function?} onFulfilled callback to be called when x is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} onRejected callback to be called when x is\n\t *   rejected.\n\t * @param {function?} onProgress callback to be called when progress updates\n\t *   are issued for x. @deprecated\n\t * @returns {Promise} a new promise that will fulfill with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(x, onFulfilled, onRejected, onProgress) {\n\t\tvar p = Promise.resolve(x);\n\t\tif (arguments.length < 2) {\n\t\t\treturn p;\n\t\t}\n\n\t\treturn p.then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn new Promise(resolver);\n\t}\n\n\t/**\n\t * Lift the supplied function, creating a version of f that returns\n\t * promises, and accepts promises as arguments.\n\t * @param {function} f\n\t * @returns {Function} version of f that returns promises\n\t */\n\tfunction lift(f) {\n\t\treturn function() {\n\t\t\tfor(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {\n\t\t\t\ta[i] = arguments[i];\n\t\t\t}\n\t\t\treturn apply(f, this, a);\n\t\t};\n\t}\n\n\t/**\n\t * Call f in a future turn, with the supplied args, and return a promise\n\t * for the result.\n\t * @param {function} f\n\t * @returns {Promise}\n\t */\n\tfunction attempt(f /*, args... */) {\n\t\t/*jshint validthis:true */\n\t\tfor(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {\n\t\t\ta[i] = arguments[i+1];\n\t\t}\n\t\treturn apply(f, this, a);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n\t */\n\tfunction defer() {\n\t\treturn new Deferred();\n\t}\n\n\tfunction Deferred() {\n\t\tvar p = Promise._defer();\n\n\t\tfunction resolve(x) { p._handler.resolve(x); }\n\t\tfunction reject(x) { p._handler.reject(x); }\n\t\tfunction notify(x) { p._handler.notify(x); }\n\n\t\tthis.promise = p;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t\tthis.notify = notify;\n\t\tthis.resolver = { resolve: resolve, reject: reject, notify: notify };\n\t}\n\n\t/**\n\t * Determines if x is promise-like, i.e. a thenable object\n\t * NOTE: Will return true for *any thenable object*, and isn't truly\n\t * safe, since it may attempt to access the `then` property of x (i.e.\n\t *  clever/malicious getters may do weird things)\n\t * @param {*} x anything\n\t * @returns {boolean} true if x is promise-like\n\t */\n\tfunction isPromiseLike(x) {\n\t\treturn x && typeof x.then === 'function';\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied arguments\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the arguments.\n\t * @param {...*} arguments may be a mix of promises and values\n\t * @returns {Promise}\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn Promise.all(arguments);\n\t}\n\n\t/**\n\t * Return a promise that will fulfill once all input promises have\n\t * fulfilled, or reject when any one input promise rejects.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise}\n\t */\n\tfunction all(promises) {\n\t\treturn when(promises, Promise.all);\n\t}\n\n\t/**\n\t * Return a promise that will always fulfill with an array containing\n\t * the outcome states of all input promises.  The returned promise\n\t * will only reject if `promises` itself is a rejected promise.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise} promise for array of settled state descriptors\n\t */\n\tfunction settle(promises) {\n\t\treturn when(promises, Promise.settle);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} promises array of anything, may contain promises and values\n\t * @param {function(x:*, index:Number):*} mapFunc map function which may\n\t *  return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(promises, mapFunc) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.map(promises, mapFunc);\n\t\t});\n\t}\n\n\t/**\n\t * Filter the provided array of promises using the provided predicate.  Input may\n\t * contain promises and values\n\t * @param {Array|Promise} promises array of promises and values\n\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t *  Must return truthy (or promise for truthy) for items to retain.\n\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t *  for which predicate returned truthy.\n\t */\n\tfunction filter(promises, predicate) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.filter(promises, predicate);\n\t\t});\n\t}\n\n\treturn when;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/when.js\n ** module id = 11\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar env = require('../env');\n\tvar TimeoutError = require('../TimeoutError');\n\n\tfunction setTimeout(f, ms, x, y) {\n\t\treturn env.setTimer(function() {\n\t\t\tf(x, y, ms);\n\t\t}, ms);\n\t}\n\n\treturn function timed(Promise) {\n\t\t/**\n\t\t * Return a new promise whose fulfillment value is revealed only\n\t\t * after ms milliseconds\n\t\t * @param {number} ms milliseconds\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.delay = function(ms) {\n\t\t\tvar p = this._beget();\n\t\t\tthis._handler.fold(handleDelay, ms, void 0, p._handler);\n\t\t\treturn p;\n\t\t};\n\n\t\tfunction handleDelay(ms, x, h) {\n\t\t\tsetTimeout(resolveDelay, ms, x, h);\n\t\t}\n\n\t\tfunction resolveDelay(x, h) {\n\t\t\th.resolve(x);\n\t\t}\n\n\t\t/**\n\t\t * Return a new promise that rejects after ms milliseconds unless\n\t\t * this promise fulfills earlier, in which case the returned promise\n\t\t * fulfills with the same value.\n\t\t * @param {number} ms milliseconds\n\t\t * @param {Error|*=} reason optional rejection reason to use, defaults\n\t\t *   to a TimeoutError if not provided\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.timeout = function(ms, reason) {\n\t\t\tvar p = this._beget();\n\t\t\tvar h = p._handler;\n\n\t\t\tvar t = setTimeout(onTimeout, ms, reason, p._handler);\n\n\t\t\tthis._handler.visit(h,\n\t\t\t\tfunction onFulfill(x) {\n\t\t\t\t\tenv.clearTimer(t);\n\t\t\t\t\tthis.resolve(x); // this = h\n\t\t\t\t},\n\t\t\t\tfunction onReject(x) {\n\t\t\t\t\tenv.clearTimer(t);\n\t\t\t\t\tthis.reject(x); // this = h\n\t\t\t\t},\n\t\t\t\th.notify);\n\n\t\t\treturn p;\n\t\t};\n\n\t\tfunction onTimeout(reason, h, ms) {\n\t\t\tvar e = typeof reason === 'undefined'\n\t\t\t\t? new TimeoutError('timed out after ' + ms + 'ms')\n\t\t\t\t: reason;\n\t\t\th.reject(e);\n\t\t}\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/decorators/timed.js\n ** module id = 12\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/\n(function(define) { 'use strict';\ndefine(function(require) {\n\t/*jshint maxcomplexity:6*/\n\n\t// Sniff \"best\" async scheduling option\n\t// Prefer process.nextTick or MutationObserver, then check for\n\t// setTimeout, and finally vertx, since its the only env that doesn't\n\t// have setTimeout\n\n\tvar MutationObs;\n\tvar capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;\n\n\t// Default env\n\tvar setTimer = function(f, ms) { return setTimeout(f, ms); };\n\tvar clearTimer = function(t) { return clearTimeout(t); };\n\tvar asap = function (f) { return capturedSetTimeout(f, 0); };\n\n\t// Detect specific env\n\tif (isNode()) { // Node\n\t\tasap = function (f) { return process.nextTick(f); };\n\n\t} else if (MutationObs = hasMutationObserver()) { // Modern browser\n\t\tasap = initMutationObserver(MutationObs);\n\n\t} else if (!capturedSetTimeout) { // vert.x\n\t\tvar vertxRequire = require;\n\t\tvar vertx = vertxRequire('vertx');\n\t\tsetTimer = function (f, ms) { return vertx.setTimer(ms, f); };\n\t\tclearTimer = vertx.cancelTimer;\n\t\tasap = vertx.runOnLoop || vertx.runOnContext;\n\t}\n\n\treturn {\n\t\tsetTimer: setTimer,\n\t\tclearTimer: clearTimer,\n\t\tasap: asap\n\t};\n\n\tfunction isNode () {\n\t\treturn typeof process !== 'undefined' &&\n\t\t\tObject.prototype.toString.call(process) === '[object process]';\n\t}\n\n\tfunction hasMutationObserver () {\n\t\treturn (typeof MutationObserver === 'function' && MutationObserver) ||\n\t\t\t(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);\n\t}\n\n\tfunction initMutationObserver(MutationObserver) {\n\t\tvar scheduled;\n\t\tvar node = document.createTextNode('');\n\t\tvar o = new MutationObserver(run);\n\t\to.observe(node, { characterData: true });\n\n\t\tfunction run() {\n\t\t\tvar f = scheduled;\n\t\t\tscheduled = void 0;\n\t\t\tf();\n\t\t}\n\n\t\tvar i = 0;\n\t\treturn function (f) {\n\t\t\tscheduled = f;\n\t\t\tnode.data = (i ^= 1);\n\t\t};\n\t}\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/env.js\n ** module id = 13\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 14\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t/**\n\t * Custom error type for promises rejected by promise.timeout\n\t * @param {string} message\n\t * @constructor\n\t */\n\tfunction TimeoutError (message) {\n\t\tError.call(this);\n\t\tthis.message = message;\n\t\tthis.name = TimeoutError.name;\n\t\tif (typeof Error.captureStackTrace === 'function') {\n\t\t\tError.captureStackTrace(this, TimeoutError);\n\t\t}\n\t}\n\n\tTimeoutError.prototype = Object.create(Error.prototype);\n\tTimeoutError.prototype.constructor = TimeoutError;\n\n\treturn TimeoutError;\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/TimeoutError.js\n ** module id = 15\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar state = require('../state');\n\tvar applier = require('../apply');\n\n\treturn function array(Promise) {\n\n\t\tvar applyFold = applier(Promise);\n\t\tvar toPromise = Promise.resolve;\n\t\tvar all = Promise.all;\n\n\t\tvar ar = Array.prototype.reduce;\n\t\tvar arr = Array.prototype.reduceRight;\n\t\tvar slice = Array.prototype.slice;\n\n\t\t// Additional array combinators\n\n\t\tPromise.any = any;\n\t\tPromise.some = some;\n\t\tPromise.settle = settle;\n\n\t\tPromise.map = map;\n\t\tPromise.filter = filter;\n\t\tPromise.reduce = reduce;\n\t\tPromise.reduceRight = reduceRight;\n\n\t\t/**\n\t\t * When this promise fulfills with an array, do\n\t\t * onFulfilled.apply(void 0, array)\n\t\t * @param {function} onFulfilled function to apply\n\t\t * @returns {Promise} promise for the result of applying onFulfilled\n\t\t */\n\t\tPromise.prototype.spread = function(onFulfilled) {\n\t\t\treturn this.then(all).then(function(array) {\n\t\t\t\treturn onFulfilled.apply(this, array);\n\t\t\t});\n\t\t};\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * One-winner competitive race.\n\t\t * Return a promise that will fulfill when one of the promises\n\t\t * in the input array fulfills, or will reject when all promises\n\t\t * have rejected.\n\t\t * @param {array} promises\n\t\t * @returns {Promise} promise for the first fulfilled value\n\t\t */\n\t\tfunction any(promises) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\t\t\tvar l = promises.length>>>0;\n\n\t\t\tvar pending = l;\n\t\t\tvar errors = [];\n\n\t\t\tfor (var h, x, i = 0; i < l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = Promise._handler(x);\n\t\t\t\tif(h.state() > 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tPromise._visitRemaining(promises, i, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, handleFulfill, handleReject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.reject(new RangeError('any(): array must not be empty'));\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction handleFulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\terrors = null;\n\t\t\t\tthis.resolve(x); // this === resolver\n\t\t\t}\n\n\t\t\tfunction handleReject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * N-winner competitive race\n\t\t * Return a promise that will fulfill when n input promises have\n\t\t * fulfilled, or will reject when it becomes impossible for n\n\t\t * input promises to fulfill (ie when promises.length - n + 1\n\t\t * have rejected)\n\t\t * @param {array} promises\n\t\t * @param {number} n\n\t\t * @returns {Promise} promise for the earliest n fulfillment values\n\t\t *\n\t\t * @deprecated\n\t\t */\n\t\tfunction some(promises, n) {\n\t\t\t/*jshint maxcomplexity:7*/\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\n\t\t\tvar results = [];\n\t\t\tvar errors = [];\n\n\t\t\tvar l = promises.length>>>0;\n\t\t\tvar nFulfill = 0;\n\t\t\tvar nReject;\n\t\t\tvar x, i; // reused in both for() loops\n\n\t\t\t// First pass: count actual array items\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t++nFulfill;\n\t\t\t}\n\n\t\t\t// Compute actual goals\n\t\t\tn = Math.max(n, 0);\n\t\t\tnReject = (nFulfill - n + 1);\n\t\t\tnFulfill = Math.min(n, nFulfill);\n\n\t\t\tif(n > nFulfill) {\n\t\t\t\tresolver.reject(new RangeError('some(): array must contain at least '\n\t\t\t\t+ n + ' item(s), but had ' + nFulfill));\n\t\t\t} else if(nFulfill === 0) {\n\t\t\t\tresolver.resolve(results);\n\t\t\t}\n\n\t\t\t// Second pass: observe each array item, make progress toward goals\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPromise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction fulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresults.push(x);\n\t\t\t\tif(--nFulfill === 0) {\n\t\t\t\t\terrors = null;\n\t\t\t\t\tthis.resolve(results);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction reject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--nReject === 0) {\n\t\t\t\t\tresults = null;\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Apply f to the value of each promise in a list of promises\n\t\t * and return a new list containing the results.\n\t\t * @param {array} promises\n\t\t * @param {function(x:*, index:Number):*} f mapping function\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction map(promises, f) {\n\t\t\treturn Promise._traverse(f, promises);\n\t\t}\n\n\t\t/**\n\t\t * Filter the provided array of promises using the provided predicate.  Input may\n\t\t * contain promises and values\n\t\t * @param {Array} promises array of promises and values\n\t\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t\t *  Must return truthy (or promise for truthy) for items to retain.\n\t\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t\t *  for which predicate returned truthy.\n\t\t */\n\t\tfunction filter(promises, predicate) {\n\t\t\tvar a = slice.call(promises);\n\t\t\treturn Promise._traverse(predicate, a).then(function(keep) {\n\t\t\t\treturn filterSync(a, keep);\n\t\t\t});\n\t\t}\n\n\t\tfunction filterSync(promises, keep) {\n\t\t\t// Safe because we know all promises have fulfilled if we've made it this far\n\t\t\tvar l = keep.length;\n\t\t\tvar filtered = new Array(l);\n\t\t\tfor(var i=0, j=0; i<l; ++i) {\n\t\t\t\tif(keep[i]) {\n\t\t\t\t\tfiltered[j++] = Promise._handler(promises[i]).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiltered.length = j;\n\t\t\treturn filtered;\n\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that will always fulfill with an array containing\n\t\t * the outcome states of all input promises.  The returned promise\n\t\t * will never reject.\n\t\t * @param {Array} promises\n\t\t * @returns {Promise} promise for array of settled state descriptors\n\t\t */\n\t\tfunction settle(promises) {\n\t\t\treturn all(promises.map(settleOne));\n\t\t}\n\n\t\tfunction settleOne(p) {\n\t\t\tvar h = Promise._handler(p);\n\t\t\tif(h.state() === 0) {\n\t\t\t\treturn toPromise(p).then(state.fulfilled, state.rejected);\n\t\t\t}\n\n\t\t\th._unreport();\n\t\t\treturn state.inspect(h);\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduce(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: ar.call(promises, liftCombine(f));\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduceRight(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: arr.call(promises, liftCombine(f));\n\t\t}\n\n\t\tfunction liftCombine(f) {\n\t\t\treturn function(z, x, i) {\n\t\t\t\treturn applyFold(f, void 0, [z,x,i]);\n\t\t\t};\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/decorators/array.js\n ** module id = 16\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tpending: toPendingState,\n\t\tfulfilled: toFulfilledState,\n\t\trejected: toRejectedState,\n\t\tinspect: inspect\n\t};\n\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\tfunction toRejectedState(e) {\n\t\treturn { state: 'rejected', reason: e };\n\t}\n\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\tfunction inspect(handler) {\n\t\tvar state = handler.state();\n\t\treturn state === 0 ? toPendingState()\n\t\t\t : state > 0   ? toFulfilledState(handler.value)\n\t\t\t               : toRejectedState(handler.value);\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/state.js\n ** module id = 17\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\tmakeApply.tryCatchResolve = tryCatchResolve;\n\n\treturn makeApply;\n\n\tfunction makeApply(Promise, call) {\n\t\tif(arguments.length < 2) {\n\t\t\tcall = tryCatchResolve;\n\t\t}\n\n\t\treturn apply;\n\n\t\tfunction apply(f, thisArg, args) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar l = args.length;\n\t\t\tvar params = new Array(l);\n\t\t\tcallAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);\n\n\t\t\treturn p;\n\t\t}\n\n\t\tfunction callAndResolve(c, h) {\n\t\t\tif(c.i < 0) {\n\t\t\t\treturn call(c.f, c.thisArg, c.params, h);\n\t\t\t}\n\n\t\t\tvar handler = Promise._handler(c.args[c.i]);\n\t\t\thandler.fold(callAndResolveNext, c, void 0, h);\n\t\t}\n\n\t\tfunction callAndResolveNext(c, x, h) {\n\t\t\tc.params[c.i] = x;\n\t\t\tc.i -= 1;\n\t\t\tcallAndResolve(c, h);\n\t\t}\n\t}\n\n\tfunction tryCatchResolve(f, thisArg, args, resolver) {\n\t\ttry {\n\t\t\tresolver.resolve(f.apply(thisArg, args));\n\t\t} catch(e) {\n\t\t\tresolver.reject(e);\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/apply.js\n ** module id = 18\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function flow(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\t\tvar reject = Promise.reject;\n\t\tvar origCatch = Promise.prototype['catch'];\n\n\t\t/**\n\t\t * Handle the ultimate fulfillment value or rejection reason, and assume\n\t\t * responsibility for all errors.  If an error propagates out of result\n\t\t * or handleFatalError, it will be rethrown to the host, resulting in a\n\t\t * loud stack track on most platforms and a crash on some.\n\t\t * @param {function?} onResult\n\t\t * @param {function?} onError\n\t\t * @returns {undefined}\n\t\t */\n\t\tPromise.prototype.done = function(onResult, onError) {\n\t\t\tthis._handler.visit(this._handler.receiver, onResult, onError);\n\t\t};\n\n\t\t/**\n\t\t * Add Error-type and predicate matching to catch.  Examples:\n\t\t * promise.catch(TypeError, handleTypeError)\n\t\t *   .catch(predicate, handleMatchedErrors)\n\t\t *   .catch(handleRemainingErrors)\n\t\t * @param onRejected\n\t\t * @returns {*}\n\t\t */\n\t\tPromise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {\n\t\t\tif (arguments.length < 2) {\n\t\t\t\treturn origCatch.call(this, onRejected);\n\t\t\t}\n\n\t\t\tif(typeof onRejected !== 'function') {\n\t\t\t\treturn this.ensure(rejectInvalidPredicate);\n\t\t\t}\n\n\t\t\treturn origCatch.call(this, createCatchFilter(arguments[1], onRejected));\n\t\t};\n\n\t\t/**\n\t\t * Wraps the provided catch handler, so that it will only be called\n\t\t * if the predicate evaluates truthy\n\t\t * @param {?function} handler\n\t\t * @param {function} predicate\n\t\t * @returns {function} conditional catch handler\n\t\t */\n\t\tfunction createCatchFilter(handler, predicate) {\n\t\t\treturn function(e) {\n\t\t\t\treturn evaluatePredicate(e, predicate)\n\t\t\t\t\t? handler.call(this, e)\n\t\t\t\t\t: reject(e);\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} handler handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['finally'] = Promise.prototype.ensure = function(handler) {\n\t\t\tif(typeof handler !== 'function') {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\treturn this.then(function(x) {\n\t\t\t\treturn runSideEffect(handler, this, identity, x);\n\t\t\t}, function(e) {\n\t\t\t\treturn runSideEffect(handler, this, reject, e);\n\t\t\t});\n\t\t};\n\n\t\tfunction runSideEffect (handler, thisArg, propagate, value) {\n\t\t\tvar result = handler.call(thisArg);\n\t\t\treturn maybeThenable(result)\n\t\t\t\t? propagateValue(result, propagate, value)\n\t\t\t\t: propagate(value);\n\t\t}\n\n\t\tfunction propagateValue (result, propagate, x) {\n\t\t\treturn resolve(result).then(function () {\n\t\t\t\treturn propagate(x);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Recover from a failure by returning a defaultValue.  If defaultValue\n\t\t * is a promise, it's fulfillment value will be used.  If defaultValue is\n\t\t * a promise that rejects, the returned promise will reject with the\n\t\t * same reason.\n\t\t * @param {*} defaultValue\n\t\t * @returns {Promise} new promise\n\t\t */\n\t\tPromise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {\n\t\t\treturn this.then(void 0, function() {\n\t\t\t\treturn defaultValue;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\tPromise.prototype['yield'] = function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Runs a side effect when this promise fulfills, without changing the\n\t\t * fulfillment value.\n\t\t * @param {function} onFulfilledSideEffect\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.tap = function(onFulfilledSideEffect) {\n\t\t\treturn this.then(onFulfilledSideEffect)['yield'](this);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n\tfunction rejectInvalidPredicate() {\n\t\tthrow new TypeError('catch predicate must be a function');\n\t}\n\n\tfunction evaluatePredicate(e, predicate) {\n\t\treturn isError(predicate) ? e instanceof predicate : predicate(e);\n\t}\n\n\tfunction isError(predicate) {\n\t\treturn predicate === Error\n\t\t\t|| (predicate != null && predicate.prototype instanceof Error);\n\t}\n\n\tfunction maybeThenable(x) {\n\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t}\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/decorators/flow.js\n ** module id = 19\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n/** @author Jeff Escalante */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function fold(Promise) {\n\n\t\tPromise.prototype.fold = function(f, z) {\n\t\t\tvar promise = this._beget();\n\n\t\t\tthis._handler.fold(function(z, x, to) {\n\t\t\t\tPromise._handler(z).fold(function(x, z, to) {\n\t\t\t\t\tto.resolve(f.call(this, z, x));\n\t\t\t\t}, x, this, to);\n\t\t\t}, z, promise._handler.receiver, promise._handler);\n\n\t\t\treturn promise;\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/decorators/fold.js\n ** module id = 20\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar inspect = require('../state').inspect;\n\n\treturn function inspection(Promise) {\n\n\t\tPromise.prototype.inspect = function() {\n\t\t\treturn inspect(Promise._handler(this));\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/decorators/inspect.js\n ** module id = 21\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function generate(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\n\t\tPromise.iterate = iterate;\n\t\tPromise.unfold = unfold;\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.iterate\n\t\t * Generate a (potentially infinite) stream of promised values:\n\t\t * x, f(x), f(f(x)), etc. until condition(x) returns true\n\t\t * @param {function} f function to generate a new x from the previous x\n\t\t * @param {function} condition function that, given the current x, returns\n\t\t *  truthy when the iterate should stop\n\t\t * @param {function} handler function to handle the value produced by f\n\t\t * @param {*|Promise} x starting value, may be a promise\n\t\t * @return {Promise} the result of the last call to f before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction iterate(f, condition, handler, x) {\n\t\t\treturn unfold(function(x) {\n\t\t\t\treturn [x, f(x)];\n\t\t\t}, condition, handler, x);\n\t\t}\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.unfold\n\t\t * Generate a (potentially infinite) stream of promised values\n\t\t * by applying handler(generator(seed)) iteratively until\n\t\t * condition(seed) returns true.\n\t\t * @param {function} unspool function that generates a [value, newSeed]\n\t\t *  given a seed.\n\t\t * @param {function} condition function that, given the current seed, returns\n\t\t *  truthy when the unfold should stop\n\t\t * @param {function} handler function to handle the value produced by unspool\n\t\t * @param x {*|Promise} starting value, may be a promise\n\t\t * @return {Promise} the result of the last value produced by unspool before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction unfold(unspool, condition, handler, x) {\n\t\t\treturn resolve(x).then(function(seed) {\n\t\t\t\treturn resolve(condition(seed)).then(function(done) {\n\t\t\t\t\treturn done ? seed : resolve(unspool(seed)).spread(next);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfunction next(item, newSeed) {\n\t\t\t\treturn resolve(handler(item)).then(function() {\n\t\t\t\t\treturn unfold(unspool, condition, handler, newSeed);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/decorators/iterate.js\n ** module id = 22\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function progress(Promise) {\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Register a progress handler for this promise\n\t\t * @param {function} onProgress\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.progress = function(onProgress) {\n\t\t\treturn this.then(void 0, void 0, onProgress);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/decorators/progress.js\n ** module id = 23\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function addWith(Promise) {\n\t\t/**\n\t\t * Returns a promise whose handlers will be called with `this` set to\n\t\t * the supplied receiver.  Subsequent promises derived from the\n\t\t * returned promise will also have their handlers called with receiver\n\t\t * as `this`. Calling `with` with undefined or no arguments will return\n\t\t * a promise whose handlers will again be called in the usual Promises/A+\n\t\t * way (no `this`) thus safely undoing any previous `with` in the\n\t\t * promise chain.\n\t\t *\n\t\t * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+\n\t\t * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)\n\t\t *\n\t\t * @param {object} receiver `this` value for all handlers attached to\n\t\t *  the returned promise.\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['with'] = Promise.prototype.withThis = function(receiver) {\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\t\t\tchild.receiver = receiver;\n\t\t\tthis._handler.chain(child, receiver);\n\t\t\treturn p;\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/decorators/with.js\n ** module id = 24\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar setTimer = require('../env').setTimer;\n\tvar format = require('../format');\n\n\treturn function unhandledRejection(Promise) {\n\n\t\tvar logError = noop;\n\t\tvar logInfo = noop;\n\t\tvar localConsole;\n\n\t\tif(typeof console !== 'undefined') {\n\t\t\t// Alias console to prevent things like uglify's drop_console option from\n\t\t\t// removing console.log/error. Unhandled rejections fall into the same\n\t\t\t// category as uncaught exceptions, and build tools shouldn't silence them.\n\t\t\tlocalConsole = console;\n\t\t\tlogError = typeof localConsole.error !== 'undefined'\n\t\t\t\t? function (e) { localConsole.error(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\n\t\t\tlogInfo = typeof localConsole.info !== 'undefined'\n\t\t\t\t? function (e) { localConsole.info(e); }\n\t\t\t\t: function (e) { localConsole.log(e); };\n\t\t}\n\n\t\tPromise.onPotentiallyUnhandledRejection = function(rejection) {\n\t\t\tenqueue(report, rejection);\n\t\t};\n\n\t\tPromise.onPotentiallyUnhandledRejectionHandled = function(rejection) {\n\t\t\tenqueue(unreport, rejection);\n\t\t};\n\n\t\tPromise.onFatalRejection = function(rejection) {\n\t\t\tenqueue(throwit, rejection.value);\n\t\t};\n\n\t\tvar tasks = [];\n\t\tvar reported = [];\n\t\tvar running = null;\n\n\t\tfunction report(r) {\n\t\t\tif(!r.handled) {\n\t\t\t\treported.push(r);\n\t\t\t\tlogError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction unreport(r) {\n\t\t\tvar i = reported.indexOf(r);\n\t\t\tif(i >= 0) {\n\t\t\t\treported.splice(i, 1);\n\t\t\t\tlogInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));\n\t\t\t}\n\t\t}\n\n\t\tfunction enqueue(f, x) {\n\t\t\ttasks.push(f, x);\n\t\t\tif(running === null) {\n\t\t\t\trunning = setTimer(flush, 0);\n\t\t\t}\n\t\t}\n\n\t\tfunction flush() {\n\t\t\trunning = null;\n\t\t\twhile(tasks.length > 0) {\n\t\t\t\ttasks.shift()(tasks.shift());\n\t\t\t}\n\t\t}\n\n\t\treturn Promise;\n\t};\n\n\tfunction throwit(e) {\n\t\tthrow e;\n\t}\n\n\tfunction noop() {}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/decorators/unhandledRejection.js\n ** module id = 25\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tformatError: formatError,\n\t\tformatObject: formatObject,\n\t\ttryStringify: tryStringify\n\t};\n\n\t/**\n\t * Format an error into a string.  If e is an Error and has a stack property,\n\t * it's returned.  Otherwise, e is formatted using formatObject, with a\n\t * warning added about e not being a proper Error.\n\t * @param {*} e\n\t * @returns {String} formatted string, suitable for output to developers\n\t */\n\tfunction formatError(e) {\n\t\tvar s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);\n\t\treturn e instanceof Error ? s : s + ' (WARNING: non-Error used)';\n\t}\n\n\t/**\n\t * Format an object, detecting \"plain\" objects and running them through\n\t * JSON.stringify if possible.\n\t * @param {Object} o\n\t * @returns {string}\n\t */\n\tfunction formatObject(o) {\n\t\tvar s = String(o);\n\t\tif(s === '[object Object]' && typeof JSON !== 'undefined') {\n\t\t\ts = tryStringify(o, s);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Try to return the result of JSON.stringify(x).  If that fails, return\n\t * defaultValue\n\t * @param {*} x\n\t * @param {*} defaultValue\n\t * @returns {String|*} JSON.stringify(x) or defaultValue\n\t */\n\tfunction tryStringify(x, defaultValue) {\n\t\ttry {\n\t\t\treturn JSON.stringify(x);\n\t\t} catch(e) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/format.js\n ** module id = 26\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar makePromise = require('./makePromise');\n\tvar Scheduler = require('./Scheduler');\n\tvar async = require('./env').asap;\n\n\treturn makePromise({\n\t\tscheduler: new Scheduler(async)\n\t});\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/Promise.js\n ** module id = 27\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\t\tvar emitRejection = initEmitRejection();\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @param {function=} onProgress @deprecated progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\treturn begetFrom(this._handler, this.constructor);\n\t\t};\n\n\t\tfunction begetFrom(parent, Promise) {\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new Promise(Handler, child);\n\t\t}\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\t\tPromise._traverse = traverse;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\treturn traverseWith(snd, null, promises);\n\t\t}\n\n\t\t/**\n\t\t * Array<Promise<X>> -> Promise<Array<f(X)>>\n\t\t * @private\n\t\t * @param {function} f function to apply to each promise's value\n\t\t * @param {Array} promises array of promises\n\t\t * @returns {Promise} promise for transformed values\n\t\t */\n\t\tfunction traverse(f, promises) {\n\t\t\treturn traverseWith(tryCatch2, f, promises);\n\t\t}\n\n\t\tfunction traverseWith(tryMap, f, promises) {\n\t\t\tvar handler = typeof f === 'function' ? mapAt : settleAt;\n\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tfor (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttraverseAt(promises, handler, i, x, resolver);\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction mapAt(i, x, resolver) {\n\t\t\t\tif(!resolver.resolved) {\n\t\t\t\t\ttraverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\tresults[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction traverseAt(promises, handler, i, x, resolver) {\n\t\t\tif (maybeThenable(x)) {\n\t\t\t\tvar h = getHandlerMaybeThenable(x);\n\t\t\t\tvar s = h.state();\n\n\t\t\t\tif (s === 0) {\n\t\t\t\t\th.fold(handler, i, void 0, resolver);\n\t\t\t\t} else if (s > 0) {\n\t\t\t\t\thandler(i, h.value, resolver);\n\t\t\t\t} else {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandler(i, x, resolver);\n\t\t\t}\n\t\t}\n\n\t\tPromise._visitRemaining = visitRemaining;\n\t\tfunction visitRemaining(promises, start, handler) {\n\t\t\tfor(var i=start; i<promises.length; ++i) {\n\t\t\t\tmarkAsHandled(getHandler(promises[i]), handler);\n\t\t\t}\n\t\t}\n\n\t\tfunction markAsHandled(h, handler) {\n\t\t\tif(h === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar s = h.state();\n\t\t\tif(s === 0) {\n\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t} else if(s < 0) {\n\t\t\t\th._unreport();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\tif(typeof promises !== 'object' || promises === null) {\n\t\t\t\treturn reject(new TypeError('non-iterable passed to race()'));\n\t\t\t}\n\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\treturn promises.length === 0 ? never()\n\t\t\t\t : promises.length === 1 ? resolve(promises[0])\n\t\t\t\t : runRace(promises);\n\t\t}\n\n\t\tfunction runRace(promises) {\n\t\t\tvar resolver = new Pending();\n\t\t\tvar i, x, h;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = getHandler(x);\n\t\t\t\tif(h.state() !== 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, resolver);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify // deprecated\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.when(new Fold(f, z, c, to));\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.handler;\n\t\t\tthis.handler = this.handler.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tif(this.handled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tthis.reported = true;\n\t\t\temitRejection('unhandledRejection', this);\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled && !this.rejection.reported) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\temitRejection('unhandledRejection', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\temitRejection('rejectionHandled', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fold a handler value with z\n\t\t * @constructor\n\t\t */\n\t\tfunction Fold(f, z, c, to) {\n\t\t\tthis.f = f; this.z = z; this.c = c; this.to = to;\n\t\t\tthis.resolver = failIfRejected;\n\t\t\tthis.receiver = this;\n\t\t}\n\n\t\tFold.prototype.fulfilled = function(x) {\n\t\t\tthis.f.call(this.c, this.z, x, this.to);\n\t\t};\n\n\t\tFold.prototype.rejected = function(x) {\n\t\t\tthis.to.reject(x);\n\t\t};\n\n\t\tFold.prototype.progress = function(x) {\n\t\t\tthis.to.notify(x);\n\t\t};\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction tryCatch2(f, a, b) {\n\t\t\ttry {\n\t\t\t\treturn f(a, b);\n\t\t\t} catch(e) {\n\t\t\t\treturn reject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction snd(x, y) {\n\t\t\treturn y;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\tfunction initEmitRejection() {\n\t\t\t/*global process, self, CustomEvent*/\n\t\t\tif(typeof process !== 'undefined' && process !== null\n\t\t\t\t&& typeof process.emit === 'function') {\n\t\t\t\t// Returning falsy here means to call the default\n\t\t\t\t// onPotentiallyUnhandledRejection API.  This is safe even in\n\t\t\t\t// browserify since process.emit always returns falsy in browserify:\n\t\t\t\t// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\treturn type === 'unhandledRejection'\n\t\t\t\t\t\t? process.emit(type, rejection.value, rejection)\n\t\t\t\t\t\t: process.emit(type, rejection);\n\t\t\t\t};\n\t\t\t} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {\n\t\t\t\treturn (function(noop, self, CustomEvent) {\n\t\t\t\t\tvar hasCustomEvent = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar ev = new CustomEvent('unhandledRejection');\n\t\t\t\t\t\thasCustomEvent = ev instanceof CustomEvent;\n\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\treturn !hasCustomEvent ? noop : function(type, rejection) {\n\t\t\t\t\t\tvar ev = new CustomEvent(type, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbubbles: false,\n\t\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(noop, self, CustomEvent));\n\t\t\t}\n\n\t\t\treturn noop;\n\t\t}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/makePromise.js\n ** module id = 28\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._running = false;\n\n\t\tthis._queue = this;\n\t\tthis._queueLen = 0;\n\t\tthis._afterQueue = {};\n\t\tthis._afterQueueLen = 0;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._queue[this._queueLen++] = task;\n\t\tthis.run();\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._afterQueue[this._afterQueueLen++] = task;\n\t\tthis.run();\n\t};\n\n\tScheduler.prototype.run = function() {\n\t\tif (!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\tvar i = 0;\n\t\tfor (; i < this._queueLen; ++i) {\n\t\t\tthis._queue[i].run();\n\t\t\tthis._queue[i] = void 0;\n\t\t}\n\n\t\tthis._queueLen = 0;\n\t\tthis._running = false;\n\n\t\tfor (i = 0; i < this._afterQueueLen; ++i) {\n\t\t\tthis._afterQueue[i].run();\n\t\t\tthis._afterQueue[i] = void 0;\n\t\t}\n\n\t\tthis._afterQueueLen = 0;\n\t};\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/Scheduler.js\n ** module id = 29\n ** module chunks = 0\n **/","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function liftAll(liftOne, combine, dst, src) {\n\t\tif(typeof combine === 'undefined') {\n\t\t\tcombine = defaultCombine;\n\t\t}\n\n\t\treturn Object.keys(src).reduce(function(dst, key) {\n\t\t\tvar f = src[key];\n\t\t\treturn typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;\n\t\t}, typeof dst === 'undefined' ? defaultDst(src) : dst);\n\t};\n\n\tfunction defaultCombine(o, f, k) {\n\t\to[k] = f;\n\t\treturn o;\n\t}\n\n\tfunction defaultDst(src) {\n\t\treturn typeof src === 'function' ? src.bind() : Object.create(src);\n\t}\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/when/lib/liftAll.js\n ** module id = 30\n ** module chunks = 0\n **/"],"sourceRoot":""}